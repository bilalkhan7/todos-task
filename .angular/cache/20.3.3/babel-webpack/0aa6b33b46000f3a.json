{"ast":null,"code":"import { Observable, Subscription, asapScheduler, ReplaySubject, isObservable, of, queueScheduler, EMPTY, throwError, scheduled, combineLatest, Subject } from 'rxjs';\nimport { take, takeUntil, observeOn, tap, withLatestFrom, map, catchError, distinctUntilChanged, shareReplay } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, computed, isDevMode, Optional, Inject, Injectable } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\n/**\n * @license MIT License\n *\n * Copyright (c) 2017-2020 Nicholas Jamieson and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nfunction debounceSync() {\n  return source => new Observable(observer => {\n    let actionSubscription;\n    let actionValue;\n    const rootSubscription = new Subscription();\n    rootSubscription.add(source.subscribe({\n      complete: () => {\n        if (actionSubscription) {\n          observer.next(actionValue);\n        }\n        observer.complete();\n      },\n      error: error => {\n        observer.error(error);\n      },\n      next: value => {\n        actionValue = value;\n        if (!actionSubscription) {\n          actionSubscription = asapScheduler.schedule(() => {\n            observer.next(actionValue);\n            actionSubscription = undefined;\n          });\n          rootSubscription.add(actionSubscription);\n        }\n      }\n    }));\n    return rootSubscription;\n  });\n}\n\n/**\n * Checks to see if the OnInitStore lifecycle hook\n * is defined on the ComponentStore.\n *\n * @param cs ComponentStore type\n * @returns boolean\n */\nfunction isOnStoreInitDefined(cs) {\n  return typeof cs.ngrxOnStoreInit === 'function';\n}\n/**\n * Checks to see if the OnInitState lifecycle hook\n * is defined on the ComponentStore.\n *\n * @param cs ComponentStore type\n * @returns boolean\n */\nfunction isOnStateInitDefined(cs) {\n  return typeof cs.ngrxOnStateInit === 'function';\n}\n/**\n * @description\n *\n * Function that returns the ComponentStore\n * class registered as a provider,\n * and uses a factory provider to instantiate the\n * ComponentStore and run the lifecycle hooks\n * defined on the ComponentStore.\n *\n * @param componentStoreClass The ComponentStore with lifecycle hooks\n * @returns Provider[]\n *\n * @usageNotes\n *\n * ```ts\n * @Injectable()\n * export class MyStore\n *    extends ComponentStore<{ init: boolean }>\n *    implements OnStoreInit, OnStateInit\n *   {\n *\n *   constructor() {\n *     super({ init: true });\n *   }\n *\n *   ngrxOnStoreInit() {\n *     // runs once after store has been instantiated\n *   }\n *\n *   ngrxOnStateInit() {\n *     // runs once after store state has been initialized\n *   }\n * }\n *\n * @Component({\n *   providers: [\n *     provideComponentStore(MyStore)\n *   ]\n * })\n * export class MyComponent {\n *   constructor(private myStore: MyStore) {}\n * }\n * ```\n */\nfunction provideComponentStore(componentStoreClass) {\n  const CS_WITH_HOOKS = new InjectionToken('@ngrx/component-store ComponentStore with Hooks');\n  return [{\n    provide: CS_WITH_HOOKS,\n    useClass: componentStoreClass\n  }, {\n    provide: componentStoreClass,\n    useFactory: () => {\n      const componentStore = inject(CS_WITH_HOOKS);\n      // Set private property that CS has been provided with lifecycle hooks\n      componentStore['ÉµhasProvider'] = true;\n      if (isOnStoreInitDefined(componentStore)) {\n        componentStore.ngrxOnStoreInit();\n      }\n      if (isOnStateInitDefined(componentStore)) {\n        componentStore.state$.pipe(take(1)).subscribe(() => componentStore.ngrxOnStateInit());\n      }\n      return componentStore;\n    }\n  }];\n}\nconst INITIAL_STATE_TOKEN = new InjectionToken('@ngrx/component-store Initial State');\nlet ComponentStore = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class ComponentStore {\n    constructor(defaultState) {\n      // Should be used only in ngOnDestroy.\n      this.destroySubject$ = new ReplaySubject(1);\n      // Exposed to any extending Store to be used for the teardown.\n      this.destroy$ = this.destroySubject$.asObservable();\n      this.stateSubject$ = new ReplaySubject(1);\n      this.isInitialized = false;\n      // Needs to be after destroy$ is declared because it's used in select.\n      this.state$ = this.select(s => s);\n      this.state = toSignal(this.stateSubject$.pipe(takeUntil(this.destroy$)), {\n        requireSync: false,\n        manualCleanup: true\n      });\n      this.ÉµhasProvider = false;\n      // State can be initialized either through constructor or setState.\n      if (defaultState) {\n        this.initState(defaultState);\n      }\n      this.checkProviderForHooks();\n    }\n    /** Completes all relevant Observable streams. */\n    ngOnDestroy() {\n      this.stateSubject$.complete();\n      this.destroySubject$.next();\n    }\n    /**\n     * Creates an updater.\n     *\n     * Throws an error if updater is called with synchronous values (either\n     * imperative value or Observable that is synchronous) before ComponentStore\n     * is initialized. If called with async Observable before initialization then\n     * state will not be updated and subscription would be closed.\n     *\n     * @param updaterFn A static updater function that takes 2 parameters (the\n     * current state and an argument object) and returns a new instance of the\n     * state.\n     * @return A function that accepts one argument which is forwarded as the\n     *     second argument to `updaterFn`. Every time this function is called\n     *     subscribers will be notified of the state change.\n     */\n    updater(updaterFn) {\n      return observableOrValue => {\n        // We need to explicitly throw an error if a synchronous error occurs.\n        // This is necessary to make synchronous errors catchable.\n        let isSyncUpdate = true;\n        let syncError;\n        // We can receive either the value or an observable. In case it's a\n        // simple value, we'll wrap it with `of` operator to turn it into\n        // Observable.\n        const observable$ = isObservable(observableOrValue) ? observableOrValue : of(observableOrValue);\n        const subscription = observable$.pipe(\n        // Push the value into queueScheduler\n        observeOn(queueScheduler),\n        // If the state is not initialized yet, we'll throw an error.\n        tap(() => this.assertStateIsInitialized()), withLatestFrom(this.stateSubject$),\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        map(([value, currentState]) => updaterFn(currentState, value)), tap(newState => this.stateSubject$.next(newState)), catchError(error => {\n          if (isSyncUpdate) {\n            syncError = error;\n            return EMPTY;\n          }\n          return throwError(error);\n        }), takeUntil(this.destroy$)).subscribe();\n        if (syncError) {\n          throw syncError;\n        }\n        isSyncUpdate = false;\n        return subscription;\n      };\n    }\n    /**\n     * Initializes state. If it was already initialized then it resets the\n     * state.\n     */\n    initState(state) {\n      scheduled([state], queueScheduler).subscribe(s => {\n        this.isInitialized = true;\n        this.stateSubject$.next(s);\n      });\n    }\n    /**\n     * Sets the state specific value.\n     * @param stateOrUpdaterFn object of the same type as the state or an\n     * updaterFn, returning such object.\n     */\n    setState(stateOrUpdaterFn) {\n      if (typeof stateOrUpdaterFn !== 'function') {\n        this.initState(stateOrUpdaterFn);\n      } else {\n        this.updater(stateOrUpdaterFn)();\n      }\n    }\n    /**\n     * Patches the state with provided partial state.\n     *\n     * @param partialStateOrUpdaterFn a partial state or a partial updater\n     * function that accepts the state and returns the partial state.\n     * @throws Error if the state is not initialized.\n     */\n    patchState(partialStateOrUpdaterFn) {\n      const patchedState = typeof partialStateOrUpdaterFn === 'function' ? partialStateOrUpdaterFn(this.get()) : partialStateOrUpdaterFn;\n      this.updater((state, partialState) => ({\n        ...state,\n        ...partialState\n      }))(patchedState);\n    }\n    get(projector) {\n      this.assertStateIsInitialized();\n      let value;\n      this.stateSubject$.pipe(take(1)).subscribe(state => {\n        value = projector ? projector(state) : state;\n      });\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return value;\n    }\n    select(...args) {\n      const {\n        observablesOrSelectorsObject,\n        projector,\n        config\n      } = processSelectorArgs(args);\n      const source$ = hasProjectFnOnly(observablesOrSelectorsObject, projector) ? this.stateSubject$ : combineLatest(observablesOrSelectorsObject);\n      return source$.pipe(config.debounce ? debounceSync() : noopOperator(), projector ? map(projectorArgs =>\n      // projectorArgs could be an Array in case where the entire state is an Array, so adding this check\n      observablesOrSelectorsObject.length > 0 && Array.isArray(projectorArgs) ? projector(...projectorArgs) : projector(projectorArgs)) : noopOperator(), distinctUntilChanged(config.equal), shareReplay({\n        refCount: true,\n        bufferSize: 1\n      }), takeUntil(this.destroy$));\n    }\n    selectSignal(...args) {\n      const selectSignalArgs = [...args];\n      const options = typeof selectSignalArgs[args.length - 1] === 'object' ? selectSignalArgs.pop() : {};\n      const projector = selectSignalArgs.pop();\n      const signals = selectSignalArgs;\n      const computation = signals.length === 0 ? () => projector(this.state()) : () => {\n        const values = signals.map(signal => signal());\n        return projector(...values);\n      };\n      return computed(computation, options);\n    }\n    /**\n     * Creates an effect.\n     *\n     * This effect is subscribed to throughout the lifecycle of the ComponentStore.\n     * @param generator A function that takes an origin Observable input and\n     *     returns an Observable. The Observable that is returned will be\n     *     subscribed to for the life of the component.\n     * @return A function that, when called, will trigger the origin Observable.\n     */\n    effect(generator) {\n      const origin$ = new Subject();\n      generator(origin$)\n      // tied to the lifecycle ðŸ‘‡ of ComponentStore\n      .pipe(takeUntil(this.destroy$)).subscribe();\n      return observableOrValue => {\n        const observable$ = isObservable(observableOrValue) ? observableOrValue : of(observableOrValue);\n        return observable$.pipe(takeUntil(this.destroy$)).subscribe(value => {\n          // any new ðŸ‘‡ value is pushed into a stream\n          origin$.next(value);\n        });\n      };\n    }\n    /**\n     * Used to check if lifecycle hooks are defined\n     * but not used with provideComponentStore()\n     */\n    checkProviderForHooks() {\n      asapScheduler.schedule(() => {\n        if (isDevMode() && (isOnStoreInitDefined(this) || isOnStateInitDefined(this)) && !this.ÉµhasProvider) {\n          const warnings = [isOnStoreInitDefined(this) ? 'OnStoreInit' : '', isOnStateInitDefined(this) ? 'OnStateInit' : ''].filter(defined => defined);\n          console.warn(`@ngrx/component-store: ${this.constructor.name} has the ${warnings.join(' and ')} ` + 'lifecycle hook(s) implemented without being provided using the ' + `provideComponentStore(${this.constructor.name}) function. ` + `To resolve this, provide the component store via provideComponentStore(${this.constructor.name})`);\n        }\n      });\n    }\n    assertStateIsInitialized() {\n      if (!this.isInitialized) {\n        throw new Error(`${this.constructor.name} has not been initialized yet. ` + `Please make sure it is initialized before updating/getting.`);\n      }\n    }\n    /** @nocollapse */\n    /** @nocollapse */\n    static #_ = _staticBlock = () => (this.Éµfac = function ComponentStore_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ComponentStore)(i0.ÉµÉµinject(INITIAL_STATE_TOKEN, 8));\n    }, this.Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n      token: ComponentStore,\n      factory: ComponentStore.Éµfac\n    }));\n  }\n  _staticBlock();\n  return ComponentStore;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction processSelectorArgs(args) {\n  const selectorArgs = Array.from(args);\n  const defaultEqualityFn = (previous, current) => previous === current;\n  // Assign default values.\n  let config = {\n    debounce: false,\n    equal: defaultEqualityFn\n  };\n  // Last argument is either config or projector or selectorsObject\n  if (isSelectConfig(selectorArgs[selectorArgs.length - 1])) {\n    config = {\n      ...config,\n      ...selectorArgs.pop()\n    };\n  }\n  // At this point selectorArgs is either projector, selectors with projector or selectorsObject\n  if (selectorArgs.length === 1 && typeof selectorArgs[0] !== 'function') {\n    // this is a selectorsObject\n    return {\n      observablesOrSelectorsObject: selectorArgs[0],\n      projector: undefined,\n      config\n    };\n  }\n  const projector = selectorArgs.pop();\n  // The Observables to combine, if there are any left.\n  const observables = selectorArgs;\n  return {\n    observablesOrSelectorsObject: observables,\n    projector,\n    config\n  };\n}\nfunction isSelectConfig(arg) {\n  const typedArg = arg;\n  return typeof typedArg.debounce !== 'undefined' || typeof typedArg.equal !== 'undefined';\n}\nfunction hasProjectFnOnly(observablesOrSelectorsObject, projector) {\n  return Array.isArray(observablesOrSelectorsObject) && observablesOrSelectorsObject.length === 0 && projector;\n}\nfunction noopOperator() {\n  return source$ => source$;\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentStore, INITIAL_STATE_TOKEN, provideComponentStore };\n//# sourceMappingURL=ngrx-component-store.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}